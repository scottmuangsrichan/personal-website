import { createHash, randomBytes } from "node:crypto";
import { isCI } from "ci-info";
import debug from "debug";
import gitUp from "git-up";
import { getAnonymousMeta } from "./anonymous-meta.js";
import { Config } from "./config.js";
import * as KEY from "./keys.js";
import { post } from "./post.js";
import { getRawProjectId } from "./project-id.js";
class AstroTelemetry {
  constructor(opts) {
    this.opts = opts;
    this.rawProjectId = getRawProjectId();
    this.sessionId = randomBytes(32).toString("hex");
    this.config = new Config({
      name: "astro",
      get defaults() {
        return /* @__PURE__ */ new Map([
          [KEY.TELEMETRY_ENABLED, true],
          [KEY.TELEMETRY_SALT, randomBytes(16).toString("hex")],
          [KEY.TELEMETRY_ID, randomBytes(32).toString("hex")]
        ]);
      }
    });
    this.debug = debug("astro:telemetry");
    this.queue = [];
  }
  get astroVersion() {
    return this.opts.version;
  }
  get ASTRO_TELEMETRY_DISABLED() {
    return process.env.ASTRO_TELEMETRY_DISABLED;
  }
  get TELEMETRY_DISABLED() {
    return process.env.TELEMETRY_DISABLED;
  }
  getWithFallback(key, value) {
    const val = this.config.get(key);
    if (val) {
      return val;
    }
    this.config.set(key, value);
    return value;
  }
  get salt() {
    return this.getWithFallback(KEY.TELEMETRY_SALT, randomBytes(16).toString("hex"));
  }
  get enabled() {
    return this.getWithFallback(KEY.TELEMETRY_ENABLED, true);
  }
  get anonymousId() {
    return this.getWithFallback(KEY.TELEMETRY_ID, randomBytes(32).toString("hex"));
  }
  get notifyDate() {
    return this.getWithFallback(KEY.TELEMETRY_NOTIFY_DATE, "");
  }
  hash(payload) {
    const hash = createHash("sha256");
    hash.update(payload);
    return hash.digest("hex");
  }
  oneWayHash(payload) {
    const hash = createHash("sha256");
    hash.update(this.salt);
    hash.update(payload);
    return hash.digest("hex");
  }
  get projectId() {
    return this.oneWayHash(this.rawProjectId);
  }
  get projectMetadata() {
    const projectId = this.rawProjectId;
    if (projectId === process.cwd()) {
      return;
    }
    const { pathname, resource } = gitUp(projectId);
    const parts = pathname.split("/").slice(1);
    const owner = `${resource}${parts[0]}`;
    const name = parts[1].replace(".git", "");
    return { owner: this.hash(owner), name: this.hash(name) };
  }
  get isDisabled() {
    if (Boolean(this.ASTRO_TELEMETRY_DISABLED || this.TELEMETRY_DISABLED)) {
      return true;
    }
    return this.enabled === false;
  }
  setEnabled(value) {
    this.config.set(KEY.TELEMETRY_ENABLED, value);
  }
  clear() {
    return this.config.clear();
  }
  async flush() {
    await Promise.all(this.queue);
  }
  async notify(callback) {
    if (this.isDisabled || isCI) {
      return;
    }
    if (this.notifyDate) {
      return;
    }
    const enabled = await callback();
    this.config.set(KEY.TELEMETRY_NOTIFY_DATE, Date.now().toString());
    this.config.set(KEY.TELEMETRY_ENABLED, enabled);
  }
  async record(event = []) {
    const events = Array.isArray(event) ? event : [event];
    if (events.length < 1) {
      return Promise.resolve();
    }
    if (this.debug.enabled) {
      events.forEach(({ eventName, payload }) => this.debug(JSON.stringify({ eventName, payload }, null, 2)));
      return Promise.resolve();
    }
    if (this.isDisabled) {
      return Promise.resolve();
    }
    const context = {
      anonymousId: this.anonymousId,
      projectId: this.projectId,
      projectMetadata: this.projectMetadata,
      sessionId: this.sessionId
    };
    const meta = getAnonymousMeta(this.astroVersion);
    const req = post({
      context,
      meta,
      events
    }).then(() => {
      this.queue = this.queue.filter((r) => r !== req);
    });
    this.queue.push(req);
    return req;
  }
}
export {
  AstroTelemetry
};
